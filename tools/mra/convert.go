package main

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

type RawClass struct {
	EOJ        string                  `json:"eoj"`
	ClassName  struct{ JA, EN string } `json:"className"`
	ShortName  string                  `json:"shortName"`
	Properties []RawProperty           `json:"elProperties"`
}

type RawProperty struct {
	EPC          string                    `json:"epc"`
	ValidRelease struct{ FROM, TO string } `json:"validRelease"`
	PropertyName struct{ JA, EN string }   `json:"propertyName"`
	ShortName    string                    `json:"shortName"`
	Descriptions struct{ JA, EN string }   `json:"descriptions"`
}

func main() {
	srcDir := os.Args[1]
	outFile := os.Args[2]

	fmt.Fprintf(os.Stderr, "srcDir: %s\n", srcDir)
	fmt.Fprintf(os.Stderr, "outFile: %s\n", outFile)

	filesSuperClass, _ := filepath.Glob(filepath.Join(srcDir, "superClass", "*.json"))
	filesNodeProfile, _ := filepath.Glob(filepath.Join(srcDir, "nodeProfile", "*.json"))
	filesDevices, _ := filepath.Glob(filepath.Join(srcDir, "devices", "*.json"))
	files := slices.Concat(filesSuperClass, filesNodeProfile, filesDevices)
	fmt.Fprintf(os.Stderr, "%d files found\n", len(files))

	f, _ := os.Create(outFile)
	defer f.Close() //nolint:errcheck

	fmt.Fprintln(f, `// Code generated by tools/mra/convert.go; DO NOT EDIT.`)
	fmt.Fprintln(f, `// Original data: ECHONET Lite Machine Readable Appendix (MRA)`)
	fmt.Fprintln(f, `package echonetlite`)
	fmt.Fprintln(f)
	fmt.Fprintln(f, `func init() {`)
	fmt.Fprintln(f, `ClassDefinitions = map[[2]byte]ClassDefinition{`)

	for _, file := range files {
		data, _ := os.ReadFile(file)

		var rc RawClass
		err := json.Unmarshal(data, &rc)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to unmarshal %s: %v\n", file, err)
			continue
		}

		// クラス定義
		eojClass, _ := hex.DecodeString(strings.TrimPrefix(rc.EOJ, "0x"))
		isNodeProfile := eojClass[0] == 0x0e && eojClass[1] == 0xf0
		fmt.Fprintf(f, `{0x%02x, 0x%02x}: {
			IsNodeProfile: %t,
			Name: %q,
			NameEN: %q,
			ShortName: %q,`+"\n",
			eojClass[0], eojClass[1],
			isNodeProfile,
			rc.ClassName.JA,
			rc.ClassName.EN,
			rc.ShortName)

		// プロパティ定義
		fmt.Fprintf(f, `Properties: []PropertyDefinition{`+"\n")

		for _, p := range rc.Properties {
			epc, _ := hex.DecodeString(strings.TrimPrefix(p.EPC, "0x"))

			releaseFrom := p.ValidRelease.FROM[0]

			var releaseTo byte
			if p.ValidRelease.TO == "latest" {
				releaseTo = 0xff
			} else {
				releaseTo = p.ValidRelease.TO[0]
			}

			fmt.Fprintf(f, `{
			  EPC: 0x%02x,
				Name: %q,
				NameEN: %q,
				ShortName: %q,
				Description: %q,
				DescriptionEN: %q,
				ValidRelease: struct{ FROM byte; TO byte }{FROM: 0x%02x, TO: 0x%02x},
			},`,
				epc[0],
				p.PropertyName.JA,
				p.PropertyName.EN,
				p.ShortName,
				p.Descriptions.JA,
				p.Descriptions.EN,
				releaseFrom,
				releaseTo)
		}

		fmt.Fprintln(f, `},`)

		// クラス定義の終了
		fmt.Fprintln(f, `},`)
	}

	fmt.Fprintln(f, `}}`)
}
